# Алгоритм Диница для поиска максимального потока в графе

В этом проекте представлено две реализации [алгоритма Диница](https://en.wikipedia.org/wiki/Dinic's_algorithm), различающиеся способом поиска блокирующего потока: более простой удаляющий обход и алгоритм Малхотры-Кумара-Махешвари, также известный как алгоритм с распространением или с потенциалами. Основным источником можно считать [этот сайт](https://wiki.algocode.ru/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0), но также использовались emaxx, википедия и конспекты прослушанных мной лекций. 

Первую реализацию можно посмотреть в коммите от 24.09. Там же можно прочитать её описание, а также ограничения, формат входных и выходных данных, применимые к обеим реализациям. Это хорошая реализация, в худшем случае работает за O(n<sup>2</sup>m). Но мне стало интересно, можно ли сделать лучше. Спойлер: наверное, пока нет. 

В этом этой итерации проекта реализован [алгоритм Диница](https://en.wikipedia.org/wiki/Dinic's_algorithm) для поиска максимального потока в графе. Для хранения графа используются списки смежности и список рёбер. Использована следующая вариация поиска блокирующего потока: для каждой вершины определяется потенциал: минимум из сумм по всем входящим и выходящим рёбрам соответственно. Далее из графа удаляются заведомо "бесперспективные" вершины с нулевым потенциалом, потенциал их соседей пересчитывается. Далее ищется вершина с минимальным ненулевым потенциалом. Так как её потенциал минимален, через любую неудалённую вершину графа можно пропустить поток, равный потенциалу данной вершины. Сделаем это с помощью поиска в глубину с удалением рёбер, как в первой реализации. Добавим этот поток и повторим всё заново пока имеется вершина с ненулевым потенциалом. Таким образом, на каждой итерации мы обнуляем потенциал одной вершины, следовательно всего итераций не более n, а каждая итерация выполняется за O(n) плюс суммарное (за все итерации) количество просмотренных рёбер, равное m, следовательно сложность такого алгоритма - O(n<sup>2</sup> + m), следовательно сложность всего алгоритма - O(n<sup>3</sup> + m*n).

Однако, на практике этот алгоритм работает медленнее, чем предыдущий. Изначально я думала, что проблема в реализации, но, судя по всему, дело не в этом. Если оценить производительность в среднем в 10<sup>7</sup> операций в секунду, (да, да, это очень приблизительно) то получается примерно то время, за которое работают тесты. [Известно](https://www.dissercat.com/content/generatsiya-testov-dlya-opredeleniya-neeffektivnykh-reshenii-olimpiadnykh-zadach-po-programm), что для некоторых алгоритмов непросто генерировать предельные тесты, и вполне возможно, что тест, оказавшийся не оказавшийся предельным для первой программы, может оказаться предельным для второй. Но, зато я могу быть уверена в корректности работы обеих решений, так как маловероятно, что такие разные решения будут давать одинаковый ответ на случайных тестах. Хорошо бы, конечно, попытаться сгенерировать гарантировано предельные тесты для обеих программ, но на это у меня не хватило времени.
